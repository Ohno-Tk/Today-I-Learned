# 書籍情報
title：オラクル認定資格教科書 Javaプログラマ Silver SE11（試験番号1Z0-815）  
ASIN ‏ : ‎ B07YDM92JZ  
link：www.amazon.co.jp/dp/B07YDM92JZ


# 書籍を呼んで気になった点
+ StringとStringBuilderの使い分け
+ 可変長引数の使い道

# Chapter1 Javaプログラミング基礎

## Javaの特徴
+ 一度書けばどこでも動く。
プログラムとOSの間に依存関係が無い。

+ Java実行環境(JVM：Java仮想マシン)による処理。
JavaはOS上で直接動くのではなく、JVMと呼ばれる実行環境上で動く。

+ オブジェクト指向
Javaはオブジェクト指向という考え方で実現できるようになっている。


## Javaプログラムのコンパイルと実行

## プログラム実行までの流れ
+ javacコマンド(コンパイラ)を使用してコンパイルを行う。
+ コンパイルによって生成されたファイルに対してjavaコマンドを使用する。
+ プログラムに文法的な誤りがあると、コンパイルエラーが表示される。
+ コンパイルが成功しプログラムが正しく動作しない事を実行時エラーという。


## ソースファイルの作り方
+ ソースファイル名や、ソースファイル内に記述する分は半角英数字を使用する。
+ 拡張子は.javaにする事。
+ 空白は半角空白かタブ文字を使用する事。


## javaアプリケーションの基本構造
```

class Sample{

	public static void main(string[] args){

		System.out.println("Hello");

	}

}

```


## コンパイル

構文
```

javac ソースファイル名.java

```


## プログラムの実行

構文
```

java クラスファイル名

```


## ソースファイルとクラスファイル
ソースファイルをコンパイルした結果生成されるクラスファイルのファイル名は、
class宣言で使用したクラス名になる。

main.javaの中身
```

class Foo{
}

```
main.javaをコンパイルするとFoo.classが生成される。

※public指定のクラスは、1つのソースファイルにつき、1つしか記述できない。


## コンパイルせずにJavaコードの実行
Java11では「Launch Single-File Source-Code programs」が導入された。
→ 一定のルールに従って書かれたJavaコードはコンパイルせずに実行することが可能


## CLASSPATH(クラスパス)
Java実行環境がクラスおよび他のソースファイルを検索するパス

## パッケージ
多くのクラスを見つけやすく、また使用しやすいように目的ごとに整理して提供する事。  
※クラス名の衝突を防ぐ役割がある。

## パッケージ化
クラスを任意のパッケージに属させること。  
※パッケージしていないクラスを無名パッケージという。  
※実行する場合は、パッケージ名に対応したディレクトリを用意する必要がある

構文
```

package パッケージ名；
class X{}

```

使用条件
+ ソースファイルの先頭にpackageキーワードで記述し「;(セミコロン)」で閉じる
+ パッケージ宣言は、必ずファイルの先頭に記述する必要がある。
+ 階層化する場合は、「.(ドット)」で区切る

## import文
自クラスが属するパッケージ以外の他クラスを参照する場合に使用

使用条件
+ ソースコードの先頭にimportキーワードを記述

※「*」使用する事で指定されたパッケージに属する全てのクラスを利用できる。  
※import文とpackage文を両方記述する場合は、package文が先頭になる。

利用される側のクラスの注意点
+ 使用するクラス、メソッドにpublic修飾子を付ける

## Java言語が提供する主なパッケージ
java.langパッケージは基本パッケージなので、import文を記述しなくても使用することが可能


# Chapter2 変数と配列
## リテラル
ソースコードに直接書き込んだ値や、その表記のこと。

リテラルの種類
+ 整数リテラル
+ 浮動小数点数リテラル
+ 文字リテラル
+ 文字列リテラル
+ 論理値リテラル
+ nullリテラル

## _がある数値リテラル
桁数の大きな数値リテラルの可読性を高めるもので、カンマの代わり
100,000を「100_000」と書ける

ルール
+ リテラルの先頭、末尾には使用できない
+ 浮動小数点リテラルにある小数点の前後には使用できない
+ float値を表現するFおよび、long値を表現するLの前には使用できない
+ 16進数でしようする0xと2進数でしようする0bの途中及び全募には使用できない

## 変数
ソースコード内で計算した値や入力した値など、プログラム内で使用するデータ保持するためのデータの入れ物。  
※変数に名前をつける事を変数名と呼びます。  
※クラスやメソッドに付ける名前は識別子と呼ぶ。

命名ルール
+ 1文字目は、英字、ドル記号、アンダースコアのみ。
+ 2文字目以降は数字も使用可能。
+ 予約語は使用不可。
+ 大文字、小文字は厳密に区別される。
+ 文字列の制限はない。


## データ型
どのような値を格納するのかを指定。  
+ 基本データ型  
整数や文字など
+ 参照型  
クラス、配列、インターフェースなどを含む基本データ型以外の型全て

## 変数宣言と代入
変数を用意する事を変数宣言
変数に値を格納することを代入

構文
```

データ型　変数名; // 変数宣言
変数名 = 値; // 変数に値を代入

```

## 定数
固定された値を扱うための変数
宣言時にfinal修飾子を使用する。

構文
```

final データ型 定数名 = 初期値;

```


## 文字列は参照型
char型は1文字しか扱うことができない。  
複数の文字列を扱う場合は参照型のデータとして扱う。


## 変数の有効範囲(スコープ)
変数は使用する前であればどこでも宣言できる。  
しかし、宣言した場所によって、その変数が使用できる範囲が制限される。


## varによる変数宣言
JDK10より、ローカル変数型推論が使用できるようになった。  
ローカル変数の宣言時に特定のデータ型を記述するのではなく、varを利用する事が出来ます。  
※メソッドの引数、コンストラクタの引数、メソッドの戻り値、フィールド(メンバ変数)、catchブロックなどでは使用できない。


## 配列
配列自体は参照型



# Chapter3 演算子と分岐文

## オペランド
演算対象となる変数やリテラルのこと

## 単項演算子の++,--
```

int a = 10;
int b = ++a;

```
計算してから代入する。

```

int a = 10;
int b = a++;

```
代入してから計算する。

## StringBuilder
変数に格納した文字列を変更することが可能


## null比較
参照型で使用されるリテラルで、何も参照していないことを表すために使用される。


## 基本データ型の型変換ルール
+ 暗黙型変換
+ キャストによる型変換


## ラッパークラスとBoxing/Unboxing
Integerクラスを使用すると、int型の値を参照型として扱えるようになる。


## 三項演算子
構文
```

条件式 ? 式1 : 式2

```

## switch文
式の結果がnullの場合、コンパイルは成功するが、  
NullPointerException例外が発生します。


# Chapter4 繰り返し文と繰り返し制御文
繰り返し文には大きく分けて3つある
+ while文
+ do-while文
+ for文

while文  
構文
```

while(条件式){
	処理文;// 条件がtrueの場合に処理分が実行される
}

```

do-while文  
構文
```

do{
	処理分;
}while(条件式)

```
for文
繰り返し文  
構文
```

for(式1;式2;式3){
	処理文;
}

```
式1  
変数の宣言及び初期化...カウンタ変数  
式1が実行されるのは初回の1回のみ

式2  
条件式を記述  

式3  
カウンタ変数の値を更新する式を記述


拡張for  
配列やコレクション  

構文
```
for(変数宣言 : 参照変数名){
	処理文
}

```
変数宣言で宣言する変数のデータ型は参照変数の各要素の型に合わせる必要がある。

ネスト(入れ子)  
+ ネストを使用することで、より複雑な処理を行える。  
+ ネストの数に制限はない

※ネストしすぎると処理の流れが複雑になり、
コードが読みにくくため


繰り返し制御文
+ break  
実行中の繰り返し処理を中断して抜け出すときに使用

例
```
while(条件式){
	break;
}
// 次の処理に制御が移る

```

+ continue  
実行中の繰り返し処理の残りの処理をスキップする。

ラベル
繰り返し文がネストしている場合、
内側の繰り返し文の中に記述したbreak文やcontinue文は、内側の繰り返し文に対してのみ適用される。

例
```
for(式1;式2;式3){
	for(式1;式2;式3){
		break ラベル名;
	}
}
ラベル名:// ここに抜け出せる

```


# Chapter5 クラス定義とオブジェクトの生成・使用
クラス  
集合データ型を表すもの  
属性とデータを定義する。
変数やメソッドをメンバと呼ぶ

オブジェクト  
システムを管理しやすい単位で分割し、それらを組み合わせて構築


クラスの定義
構文
```
[修飾子]class クラス名{}

例)
class Employee{}

```

メンバ変数
クラスの中にメンバとして変数を宣言する。

フィールド
クラスが持つべき属性を表現

インスタンス変数構文
```

[修飾子]データ型　インスタンス変数名

例)
class Employee{
	String name;
	int id = 100;
}

```

インスタンス化
クラスは設計図  
設計図を元にメモリ上に実体化させること

構文
```

データ型 変数名 = new クラス名();
例)
Employee a = new Employee();

```

インスタンス変数およびメソッドの呼び出し
```
変数名.メソッド名();

例)
a.setId(100);
```

メンバ変数とローカル変数の初期化  
メンバ変数はデフォルト値で初期化される  
ローカル変数は明示的な初期化が必要


コンストラクタ  
インスタンス化されるときに最初に呼び出される

ルール
+ 名前がクラスメイト同じ
+ 戻り値はもたない
+ 必要に応じて引数を受け取ることができる

構文
```
[修飾子]コンストラクタ(引数リスト){}
```

コンストラクタの呼び出し  
構文
```
new コンストラクタ名()
new コンストラクタ名(引数リスト)

例)
Employee e = new Employee();
Employee e = new Employee(100);
```
インスタンス化されたいときに同時に
行っておきたい処理を記述する


デフォルトコンストラクタ
クラスに1つもコンストラクタを定義しなかった場合、
コンパイラによってコンストラクタが追加される。


オーバーロード  
同じ名前のメソッドやコンストラクタを複数定義できる。  
※メソッドを区別するために、引数の並び、データ型、数が異なっている事が条件


可変長引数
引数の数を可変に扱えるように定義する事

ルール
+ データ型の後に「...」と記述する
+ 可変長引数とデータ型の異なる引数を併用できる  
※ただし、可変長引数は最後に置く
+ 可変長引数は1つしか使用できない
+ 引数リストを明確に定義したメソッドと、可変長引数を使用したメソッドが定義されている場合、引数リストを明確に定義したメソッドが優先して呼び出される


static変数・メソッド
変数宣言するときにstatic修飾子を指定する事
メソッドも同様でstatic修飾子を指定する
複数インスタンス化しても領域としては1箇所しか用意されない

呼びだすとき  
クラス名.static変数名 or staticメソッド名()

staticイニシャライザ
クラスファイルがロードされたタイミングで実行されるブロック


アクセス修飾子

|  アクセス修飾子  |  クラス  |  コンストラクタ  |  メンバ変数  |  メソッド  |  説明  |
| ---- | ---- | ---- | ---- | ---- | ---- |
|  public  |  ○  |  ○  |  ○  |  ○  |  どのクラスからでも利用可能  |
|  protected  |  ×  |  ○  |  ○  |  ○  |  このクラスを継承したサブクラス、もしくは同一パッケージ内のクラスから利用可能  |
|  デフォルト  |  ○  |  ○  |  ○  |  ○  |  同一パッケージ内のクラスから利用可能  |
|  private  |  ×  |  ○  |  ○  |  ○  |  同一クラス内からのみ利用可能  |


カプセル化
属性と操作を一本化させて表現する事  
一般的にインスタンス変数はprivate指定し、
メソッドはpublic指定する事が推奨されている

外部から属性への直接的なアクセスを避け、
操作経由でのみアクセスを許可する事で属性を保護している。


ガベージコレクタ  
プログラムが使用しなくなったメモリ領域を検出し解放する事
※ガベージコレクタがあるからといってメモリ不足が起きないわけではない


オブジェクトをガベージコレクタの対象にする  
+ nullを代入
+ 参照変数を他のオブジェクトに割り当てる


# Chapter6 継承とポリモフィズム
## 継承
既存のクラスを元に新たなクラスを定義する

## スーパークラス
継承において、元となるクラス

## サブクラス
新たに定義されるクラス  
定義する際には、extendsキーワードを使用する。  
構文
```
[修飾子]class サブクラス名 extends スーパークラス名{}

```

スーパークラスで定義した変数、メソッドは全てサブクラスに引き継がれる。

## オーバーライド
サブクラス内で、スーパークラスで定義しているメソッドと
同じ名前でメソッドを再定義する。

サブクラスがインスタンス化してメソッドが呼び出される際には、
サブクラスで再定義してメソッドが優先して呼び出される。

### オーバーライドのルール
- メソッド名、引数リストがまったく同じ
- 戻り値はスーパークラスで定義したメソッドが返す型と同じ又はその型のサブクラス型
- 修飾子は、スーパークラスと同じか、それより公開範囲が広いもの

## Overrideアノテーション
@Overrideを付与することで、「このクラスはオーバーライドしている」と明示することが可能

## final修飾子
- メソッドにつけた場合、サブクラス側でそのメソッドをオーバーライドできなくなる。
- クラスにつけた場合、クラスを元にサブクラスを作成できなくなる。

## this
自分自身(自オブジェクト)を表現する。

## super
自オブジェクトから見てスーパークラスのオブジェクトを表現する。
メソッドを呼び出す場合：super.メソッド名

## 具象クラス
処理内容を記述したメソッドを定義し、インスタンス化して使用できるクラス

## 抽象クラス(abstractクラス)
処理内容を記述しないメソッドや、それをもつクラス  
処理内容を記述しないメソッド：抽象メソッド  

構文
```
[アクセス修飾子]abstract class クラス名{}

```

### 抽象クラスが必要になる理由
抽象クラスで宣言された抽象メソッドを必ずオーバーライドしなくてはいけない  
サブクラス定義時にメソッド名や引数の数、データ型、並びに間違いがあればコンパイルエラーにより
知る事が出来、コーディングミスを避けられる。

## インターフェース
構文
```
[アクセス修飾子]interface インターフェース名{}

```

## instanceof演算子
ある特定のオブジェクトが特定の型をもつかどうか判定し、
結果をboolean値で返す。

構文
```
参照変数名 instanceof クラス名又はインターフェース名

```

## ポリモフィズム
共通のインターフェースをもつ操作でも、実際にはオブジェクトごとに振る舞いや動作が異なる事