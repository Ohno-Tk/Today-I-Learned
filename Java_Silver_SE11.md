# 書籍情報
title：オラクル認定資格教科書 Javaプログラマ Silver SE11（試験番号1Z0-815）  
ASIN ‏ : ‎ B07YDM92JZ  
link：www.amazon.co.jp/dp/B07YDM92JZ


# 書籍を呼んで気になった点
+ StringとStringBuilderの使い分け

# Chapter1 Javaプログラミング基礎

## Javaの特徴
+ 一度書けばどこでも動く。
プログラムとOSの間に依存関係が無い。

+ Java実行環境(JVM：Java仮想マシン)による処理。
JavaはOS上で直接動くのではなく、JVMと呼ばれる実行環境上で動く。

+ オブジェクト指向
Javaはオブジェクト指向という考え方で実現できるようになっている。


## Javaプログラムのコンパイルと実行

## プログラム実行までの流れ
+ javacコマンド(コンパイラ)を使用してコンパイルを行う。
+ コンパイルによって生成されたファイルに対してjavaコマンドを使用する。
+ プログラムに文法的な誤りがあると、コンパイルエラーが表示される。
+ コンパイルが成功しプログラムが正しく動作しない事を実行時エラーという。


## ソースファイルの作り方
+ ソースファイル名や、ソースファイル内に記述する分は半角英数字を使用する。
+ 拡張子は.javaにする事。
+ 空白は半角空白かタブ文字を使用する事。


## javaアプリケーションの基本構造
```

class Sample{

	public static void main(string[] args){

		System.out.println("Hello");

	}

}

```


## コンパイル

構文
```

javac ソースファイル名.java

```


## プログラムの実行

構文
```

java クラスファイル名

```


## ソースファイルとクラスファイル
ソースファイルをコンパイルした結果生成されるクラスファイルのファイル名は、
class宣言で使用したクラス名になる。

main.javaの中身
```

class Foo{
}

```
main.javaをコンパイルするとFoo.classが生成される。

※public指定のクラスは、1つのソースファイルにつき、1つしか記述できない。


## コンパイルせずにJavaコードの実行
Java11では「Launch Single-File Source-Code programs」が導入された。
→ 一定のルールに従って書かれたJavaコードはコンパイルせずに実行することが可能


## CLASSPATH(クラスパス)
Java実行環境がクラスおよび他のソースファイルを検索するパス

## パッケージ
多くのクラスを見つけやすく、また使用しやすいように目的ごとに整理して提供する事。  
※クラス名の衝突を防ぐ役割がある。

## パッケージ化
クラスを任意のパッケージに属させること。  
※パッケージしていないクラスを無名パッケージという。  
※実行する場合は、パッケージ名に対応したディレクトリを用意する必要がある

構文
```

package パッケージ名；
class X{}

```

使用条件
+ ソースファイルの先頭にpackageキーワードで記述し「;(セミコロン)」で閉じる
+ パッケージ宣言は、必ずファイルの先頭に記述する必要がある。
+ 階層化する場合は、「.(ドット)」で区切る

## import文
自クラスが属するパッケージ以外の他クラスを参照する場合に使用

使用条件
+ ソースコードの先頭にimportキーワードを記述

※「*」使用する事で指定されたパッケージに属する全てのクラスを利用できる。  
※import文とpackage文を両方記述する場合は、package文が先頭になる。

利用される側のクラスの注意点
+ 使用するクラス、メソッドにpublic修飾子を付ける

## Java言語が提供する主なパッケージ
java.langパッケージは基本パッケージなので、import文を記述しなくても使用することが可能


# Chapter2 変数と配列
## リテラル
ソースコードに直接書き込んだ値や、その表記のこと。

リテラルの種類
+ 整数リテラル
+ 浮動小数点数リテラル
+ 文字リテラル
+ 文字列リテラル
+ 論理値リテラル
+ nullリテラル

## _がある数値リテラル
桁数の大きな数値リテラルの可読性を高めるもので、カンマの代わり
100,000を「100_000」と書ける

ルール
+ リテラルの先頭、末尾には使用できない
+ 浮動小数点リテラルにある小数点の前後には使用できない
+ float値を表現するFおよび、long値を表現するLの前には使用できない
+ 16進数でしようする0xと2進数でしようする0bの途中及び全募には使用できない

## 変数
ソースコード内で計算した値や入力した値など、プログラム内で使用するデータ保持するためのデータの入れ物。  
※変数に名前をつける事を変数名と呼びます。  
※クラスやメソッドに付ける名前は識別子と呼ぶ。

命名ルール
+ 1文字目は、英字、ドル記号、アンダースコアのみ。
+ 2文字目以降は数字も使用可能。
+ 予約語は使用不可。
+ 大文字、小文字は厳密に区別される。
+ 文字列の制限はない。


## データ型
どのような値を格納するのかを指定。  
+ 基本データ型  
整数や文字など
+ 参照型  
クラス、配列、インターフェースなどを含む基本データ型以外の型全て

## 変数宣言と代入
変数を用意する事を変数宣言
変数に値を格納することを代入

構文
```

データ型　変数名; // 変数宣言
変数名 = 値; // 変数に値を代入

```

## 定数
固定された値を扱うための変数
宣言時にfinal修飾子を使用する。

構文
```

final データ型 定数名 = 初期値;

```


## 文字列は参照型
char型は1文字しか扱うことができない。  
複数の文字列を扱う場合は参照型のデータとして扱う。


## 変数の有効範囲(スコープ)
変数は使用する前であればどこでも宣言できる。  
しかし、宣言した場所によって、その変数が使用できる範囲が制限される。


## varによる変数宣言
JDK10より、ローカル変数型推論が使用できるようになった。  
ローカル変数の宣言時に特定のデータ型を記述するのではなく、varを利用する事が出来ます。  
※メソッドの引数、コンストラクタの引数、メソッドの戻り値、フィールド(メンバ変数)、catchブロックなどでは使用できない。


## 配列
配列自体は参照型



# Chapter3 演算子と分岐文

## オペランド
演算対象となる変数やリテラルのこと

## 単項演算子の++,--
```

int a = 10;
int b = ++a;

```
計算してから代入する。

```

int a = 10;
int b = a++;

```
代入してから計算する。

## StringBuilder
変数に格納した文字列を変更することが可能


## null比較
参照型で使用されるリテラルで、何も参照していないことを表すために使用される。


## 基本データ型の型変換ルール
+ 暗黙型変換
+ キャストによる型変換


## ラッパークラスとBoxing/Unboxing
Integerクラスを使用すると、int型の値を参照型として扱えるようになる。


## 三項演算子
構文
```

条件式 ? 式1 : 式2

```

## switch文
式の結果がnullの場合、コンパイルは成功するが、  
NullPointerException例外が発生します。


# Chapter4 繰り返し文と繰り返し制御文